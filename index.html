<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
        integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
        crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"
        integri-ty="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew=="
        crossorigin=""></script>
</head>
<style>
    html,
    body {
        height: 100%;
    }
</style>

<body onload="initialize()">
    <div id="map" style="width: 100%; height: 100%"></div>
</body>

</html>
<script>
    var map;
    var clients = [];
    function initialize() {
        map = L.map('map').setView([48.833, 2.333], 7);
        var osmLayer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            maxZoom: 19

        });

        map.addLayer(osmLayer);
        map.on('click', onMapClick);
        map.on('contextmenu', solveTSPv1);
    }
    function onMapClick(e) {
        //alert("You clicked the map at " + e.latlng);
        var marker = new L.marker([e.latlng.lat, e.latlng.lng]);
        marker.addTo(map);
        name = prompt("Give the name of the client");
        marker.bindTooltip(name);
        clients.push(marker);
    }
    function computeDistance(marker1, marker2) {
        return marker1.getLatLng().distanceTo(marker2.getLatLng());
    }
    function solveTSPv1() {
        currentClient = 0; //last Visited client. at the begining it is just the first client
        //at the start, all the clients are not visited
        totalDistance=0.0;
        isVisited = [];
        for (i = 0; i < clients.length; i++) isVisited.push(false);
        //except the first one : the current one
        isVisited[currentClient] = true;
        //and only one client is then visited
        nbvisited = 1;
        // while not all clients are visited
        while (nbvisited < clients.length) {
            //we will look for the closest not visited client from the current one
            minDistance = 100000000;
            for (i = 0; i < clients.length; i++) { //brows all clients
                if (!isVisited[i]) { //if not visited
                    distance = computeDistance(clients[currentClient], clients[i]); //compute the distance to the current client
                    if (distance < minDistance) { //if closest then
                        minDistance = distance; //store the closest distance
                        nextClient = i;  //and store the client
                    }
                }
            }
            isVisited[nextClient] = true;//the next client is cosidered visited
            //update the total distance 
            totalDistance+=minDistance;
            //draw a line between the current and next clients
            var pointList = [clients[currentClient].getLatLng(), clients[nextClient].getLatLng()];

            var firstpolyline = new L.Polyline(pointList);

            map.addLayer(firstpolyline);
            nbvisited++; //the number of visited client is incremented
            currentClient = nextClient; //the current client is now the next client
            
        }
        alert("the total distance is " + totalDistance);
    }
</script>